
-- generated by elm_rs


module SpecialNotes exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Data exposing (TagSearch, tagSearchDecoder, tagSearchEncoder)
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]
        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type alias Server =
    { id : Int
    , uuid : String
    }


serverEncoder : Server -> Json.Encode.Value
serverEncoder struct =
    Json.Encode.object
        [ ( "id", (Json.Encode.int) struct.id )
        , ( "uuid", (Json.Encode.string) struct.uuid )
        ]


type SpecialNote
    = SnSearch (List (TagSearch))
    | SnSync (CompletedSync)
    | SnPlaylist (Notelist)


specialNoteEncoder : SpecialNote -> Json.Encode.Value
specialNoteEncoder enum =
    case enum of
        SnSearch inner ->
            Json.Encode.object [ ( "SnSearch", Json.Encode.list (tagSearchEncoder) inner ) ]
        SnSync inner ->
            Json.Encode.object [ ( "SnSync", completedSyncEncoder inner ) ]
        SnPlaylist inner ->
            Json.Encode.object [ ( "SnPlaylist", notelistEncoder inner ) ]

type alias Search =
    { search : List (TagSearch)
    }


searchEncoder : Search -> Json.Encode.Value
searchEncoder struct =
    Json.Encode.object
        [ ( "search", (Json.Encode.list (tagSearchEncoder)) struct.search )
        ]


type alias CompletedSync =
    { after : Maybe (Int)
    , now : Int
    }


completedSyncEncoder : CompletedSync -> Json.Encode.Value
completedSyncEncoder struct =
    Json.Encode.object
        [ ( "after", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.int)) struct.after )
        , ( "now", (Json.Encode.int) struct.now )
        ]


type alias Notelist =
    { sequence : List (String)
    , current : Maybe (Int)
    }


notelistEncoder : Notelist -> Json.Encode.Value
notelistEncoder struct =
    Json.Encode.object
        [ ( "sequence", (Json.Encode.list (Json.Encode.string)) struct.sequence )
        , ( "current", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.int)) struct.current )
        ]


serverDecoder : Json.Decode.Decoder Server
serverDecoder =
    Json.Decode.succeed Server
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "id" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "uuid" (Json.Decode.string)))


specialNoteDecoder : Json.Decode.Decoder SpecialNote
specialNoteDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.map SnSearch (Json.Decode.field "SnSearch" (Json.Decode.list (tagSearchDecoder)))
        , Json.Decode.map SnSync (Json.Decode.field "SnSync" (completedSyncDecoder))
        , Json.Decode.map SnPlaylist (Json.Decode.field "SnPlaylist" (notelistDecoder))
        ]

searchDecoder : Json.Decode.Decoder Search
searchDecoder =
    Json.Decode.succeed Search
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "search" (Json.Decode.list (tagSearchDecoder))))


completedSyncDecoder : Json.Decode.Decoder CompletedSync
completedSyncDecoder =
    Json.Decode.succeed CompletedSync
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "after" (Json.Decode.nullable (Json.Decode.int))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "now" (Json.Decode.int)))


notelistDecoder : Json.Decode.Decoder Notelist
notelistDecoder =
    Json.Decode.succeed Notelist
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "sequence" (Json.Decode.list (Json.Decode.string))))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "current" (Json.Decode.nullable (Json.Decode.int))))


